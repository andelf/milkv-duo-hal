#![doc = "Peripheral access API for SG2002 microcontrollers (generated using svd2rust v0.31.5 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 7;
#[allow(unused_imports)]
use generic::*;
#[doc = "Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn UART0();
    fn UART1();
    fn UART2();
    fn UART3();
    fn UART4();
    fn GPIO0();
    fn GPIO1();
    fn GPIO2();
    fn GPIO3();
    fn PWR_GPIO();
    fn UART_RTC();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 88] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: UART0 },
    Vector { _handler: UART1 },
    Vector { _handler: UART2 },
    Vector { _handler: UART3 },
    Vector { _handler: UART4 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: GPIO0 },
    Vector { _handler: GPIO1 },
    Vector { _handler: GPIO2 },
    Vector { _handler: GPIO3 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PWR_GPIO },
    Vector { _handler: UART_RTC },
];
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts."]
    #[derive(Copy, Clone, Debug, PartialEq, Eq)]
    #[repr(u16)]
    pub enum Interrupt {
        #[doc = "60 - UART0 interrupt"]
        UART0 = 60,
        #[doc = "61 - UART1 interrupt"]
        UART1 = 61,
        #[doc = "62 - UART2 interrupt"]
        UART2 = 62,
        #[doc = "63 - UART3 interrupt"]
        UART3 = 63,
        #[doc = "64 - UART4 interrupt"]
        UART4 = 64,
        #[doc = "76 - GPIO0 interrupt"]
        GPIO0 = 76,
        #[doc = "77 - GPIO1 interrupt"]
        GPIO1 = 77,
        #[doc = "78 - GPIO2 interrupt"]
        GPIO2 = 78,
        #[doc = "79 - GPIO3 interrupt"]
        GPIO3 = 79,
        #[doc = "86 - PWR_GPIO interrupt"]
        PWR_GPIO = 86,
        #[doc = "87 - RTCSYS UART interrupt"]
        UART_RTC = 87,
    }
    #[doc = r" TryFromInterruptError"]
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[doc = r" Attempt to convert a given value into an `Interrupt`"]
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                60 => Ok(Interrupt::UART0),
                61 => Ok(Interrupt::UART1),
                62 => Ok(Interrupt::UART2),
                63 => Ok(Interrupt::UART3),
                64 => Ok(Interrupt::UART4),
                76 => Ok(Interrupt::GPIO0),
                77 => Ok(Interrupt::GPIO1),
                78 => Ok(Interrupt::GPIO2),
                79 => Ok(Interrupt::GPIO3),
                86 => Ok(Interrupt::PWR_GPIO),
                87 => Ok(Interrupt::UART_RTC),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ($ NAME : ident , $ path : path , locals : { $ ($ lvar : ident : $ lty : ty = $ lval : expr ;) * }) => { # [allow (non_snake_case)]
mod $ NAME { pub struct Locals { $ (pub $ lvar : $ lty ,) * } } # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ($ lvar : $ lval ,) * } ; let f : fn (& mut self :: $ NAME :: Locals) = $ path ; f (unsafe { & mut LOCALS }) ; } } ; ($ NAME : ident , $ path : path) => { # [allow (non_snake_case)]
# [no_mangle]
pub extern "C" fn $ NAME () { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn () = $ path ; f () ; } } }
}
pub use self::interrupt::Interrupt;
#[doc = "FMUX"]
pub struct PINMUX {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PINMUX {}
impl PINMUX {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pinmux::RegisterBlock = 0x0300_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pinmux::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for PINMUX {
    type Target = pinmux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PINMUX {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PINMUX").finish()
    }
}
#[doc = "FMUX"]
pub mod pinmux {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        pad: [PAD; 120],
    }
    impl RegisterBlock {
        #[doc = "0x00..0x1e0 - no desc"]
        #[inline(always)]
        pub const fn pad(&self, n: usize) -> &PAD {
            &self.pad[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0x1e0 - no desc"]
        #[inline(always)]
        pub fn pad_iter(&self) -> impl Iterator<Item = &PAD> {
            self.pad.iter()
        }
    }
    #[doc = "no desc"]
    pub use self::pad::PAD;
    #[doc = r"Cluster"]
    #[doc = "no desc"]
    pub mod pad {
        #[doc = r"Register block"]
        #[repr(C)]
        pub struct PAD {
            func_sel: FUNC_SEL,
        }
        impl PAD {
            #[doc = "0x00 - Function selection"]
            #[inline(always)]
            pub const fn func_sel(&self) -> &FUNC_SEL {
                &self.func_sel
            }
        }
        #[doc = "FUNC_SEL (rw) register accessor: Function selection\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`func_sel::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`func_sel::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@func_sel`]
module"]
        pub type FUNC_SEL = crate::Reg<func_sel::FUNC_SEL_SPEC>;
        #[doc = "Function selection"]
        pub mod func_sel {
            #[doc = "Register `FUNC_SEL` reader"]
            pub type R = crate::R<FUNC_SEL_SPEC>;
            #[doc = "Register `FUNC_SEL` writer"]
            pub type W = crate::W<FUNC_SEL_SPEC>;
            #[doc = "Field `VALUE` reader - Function selection"]
            pub type VALUE_R = crate::FieldReader;
            #[doc = "Field `VALUE` writer - Function selection"]
            pub type VALUE_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
            impl R {
                #[doc = "Bits 0:3 - Function selection"]
                #[inline(always)]
                pub fn value(&self) -> VALUE_R {
                    VALUE_R::new((self.bits & 0x0f) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:3 - Function selection"]
                #[inline(always)]
                #[must_use]
                pub fn value(&mut self) -> VALUE_W<FUNC_SEL_SPEC> {
                    VALUE_W::new(self, 0)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "Function selection\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`func_sel::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`func_sel::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct FUNC_SEL_SPEC;
            impl crate::RegisterSpec for FUNC_SEL_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`func_sel::R`](R) reader structure"]
            impl crate::Readable for FUNC_SEL_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`func_sel::W`](W) writer structure"]
            impl crate::Writable for FUNC_SEL_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            }
            #[doc = "`reset()` method sets FUNC_SEL to value 0"]
            impl crate::Resettable for FUNC_SEL_SPEC {
                const RESET_VALUE: u32 = 0;
            }
        }
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub struct IOBLK_G10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOBLK_G10 {}
impl IOBLK_G10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioblk_g10::RegisterBlock = 0x0300_1a00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioblk_g10::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for IOBLK_G10 {
    type Target = ioblk_g10::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOBLK_G10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOBLK_G10").finish()
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub mod ioblk_g10 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        pin: [PIN; 60],
    }
    impl RegisterBlock {
        #[doc = "0x00..0xf0 - no desc"]
        #[inline(always)]
        pub const fn pin(&self, n: usize) -> &PIN {
            &self.pin[n]
        }
        #[doc = "Iterator for array of:"]
        #[doc = "0x00..0xf0 - no desc"]
        #[inline(always)]
        pub fn pin_iter(&self) -> impl Iterator<Item = &PIN> {
            self.pin.iter()
        }
    }
    #[doc = "no desc"]
    pub use self::pin::PIN;
    #[doc = r"Cluster"]
    #[doc = "no desc"]
    pub mod pin {
        #[doc = r"Register block"]
        #[repr(C)]
        pub struct PIN {
            iocfg: IOCFG,
        }
        impl PIN {
            #[doc = "0x00 - IO conf"]
            #[inline(always)]
            pub const fn iocfg(&self) -> &IOCFG {
                &self.iocfg
            }
        }
        #[doc = "IOCFG (rw) register accessor: IO conf\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iocfg::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iocfg::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iocfg`]
module"]
        pub type IOCFG = crate::Reg<iocfg::IOCFG_SPEC>;
        #[doc = "IO conf"]
        pub mod iocfg {
            #[doc = "Register `IOCFG` reader"]
            pub type R = crate::R<IOCFG_SPEC>;
            #[doc = "Register `IOCFG` writer"]
            pub type W = crate::W<IOCFG_SPEC>;
            #[doc = "Field `PU` reader - Pull up enable"]
            pub type PU_R = crate::BitReader;
            #[doc = "Field `PU` writer - Pull up enable"]
            pub type PU_W<'a, REG> = crate::BitWriter<'a, REG>;
            #[doc = "Field `PD` reader - Pull down enable"]
            pub type PD_R = crate::BitReader;
            #[doc = "Field `PD` writer - Pull down enable"]
            pub type PD_W<'a, REG> = crate::BitWriter<'a, REG>;
            #[doc = "Field `DS` reader - Drive strength, some are 3-bit, some are 2-bit"]
            pub type DS_R = crate::FieldReader;
            #[doc = "Field `DS` writer - Drive strength, some are 3-bit, some are 2-bit"]
            pub type DS_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
            #[doc = "Field `ST` reader - Schmitt trigger enable"]
            pub type ST_R = crate::FieldReader;
            #[doc = "Field `ST` writer - Schmitt trigger enable"]
            pub type ST_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
            #[doc = "Field `HE` reader - Bus holder, some group does not have this"]
            pub type HE_R = crate::BitReader;
            #[doc = "Field `HE` writer - Bus holder, some group does not have this"]
            pub type HE_W<'a, REG> = crate::BitWriter<'a, REG>;
            #[doc = "Field `SL` reader - Skew control"]
            pub type SL_R = crate::BitReader;
            #[doc = "Field `SL` writer - Skew control"]
            pub type SL_W<'a, REG> = crate::BitWriter<'a, REG>;
            impl R {
                #[doc = "Bit 2 - Pull up enable"]
                #[inline(always)]
                pub fn pu(&self) -> PU_R {
                    PU_R::new(((self.bits >> 2) & 1) != 0)
                }
                #[doc = "Bit 3 - Pull down enable"]
                #[inline(always)]
                pub fn pd(&self) -> PD_R {
                    PD_R::new(((self.bits >> 3) & 1) != 0)
                }
                #[doc = "Bits 5:7 - Drive strength, some are 3-bit, some are 2-bit"]
                #[inline(always)]
                pub fn ds(&self) -> DS_R {
                    DS_R::new(((self.bits >> 5) & 7) as u8)
                }
                #[doc = "Bits 8:9 - Schmitt trigger enable"]
                #[inline(always)]
                pub fn st(&self) -> ST_R {
                    ST_R::new(((self.bits >> 8) & 3) as u8)
                }
                #[doc = "Bit 10 - Bus holder, some group does not have this"]
                #[inline(always)]
                pub fn he(&self) -> HE_R {
                    HE_R::new(((self.bits >> 10) & 1) != 0)
                }
                #[doc = "Bit 11 - Skew control"]
                #[inline(always)]
                pub fn sl(&self) -> SL_R {
                    SL_R::new(((self.bits >> 11) & 1) != 0)
                }
            }
            impl W {
                #[doc = "Bit 2 - Pull up enable"]
                #[inline(always)]
                #[must_use]
                pub fn pu(&mut self) -> PU_W<IOCFG_SPEC> {
                    PU_W::new(self, 2)
                }
                #[doc = "Bit 3 - Pull down enable"]
                #[inline(always)]
                #[must_use]
                pub fn pd(&mut self) -> PD_W<IOCFG_SPEC> {
                    PD_W::new(self, 3)
                }
                #[doc = "Bits 5:7 - Drive strength, some are 3-bit, some are 2-bit"]
                #[inline(always)]
                #[must_use]
                pub fn ds(&mut self) -> DS_W<IOCFG_SPEC> {
                    DS_W::new(self, 5)
                }
                #[doc = "Bits 8:9 - Schmitt trigger enable"]
                #[inline(always)]
                #[must_use]
                pub fn st(&mut self) -> ST_W<IOCFG_SPEC> {
                    ST_W::new(self, 8)
                }
                #[doc = "Bit 10 - Bus holder, some group does not have this"]
                #[inline(always)]
                #[must_use]
                pub fn he(&mut self) -> HE_W<IOCFG_SPEC> {
                    HE_W::new(self, 10)
                }
                #[doc = "Bit 11 - Skew control"]
                #[inline(always)]
                #[must_use]
                pub fn sl(&mut self) -> SL_W<IOCFG_SPEC> {
                    SL_W::new(self, 11)
                }
                #[doc = r" Writes raw bits to the register."]
                #[doc = r""]
                #[doc = r" # Safety"]
                #[doc = r""]
                #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
                #[inline(always)]
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.bits = bits;
                    self
                }
            }
            #[doc = "IO conf\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iocfg::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iocfg::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
            pub struct IOCFG_SPEC;
            impl crate::RegisterSpec for IOCFG_SPEC {
                type Ux = u32;
            }
            #[doc = "`read()` method returns [`iocfg::R`](R) reader structure"]
            impl crate::Readable for IOCFG_SPEC {}
            #[doc = "`write(|w| ..)` method takes [`iocfg::W`](W) writer structure"]
            impl crate::Writable for IOCFG_SPEC {
                const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
                const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            }
            #[doc = "`reset()` method sets IOCFG to value 0"]
            impl crate::Resettable for IOCFG_SPEC {
                const RESET_VALUE: u32 = 0;
            }
        }
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub struct IOBLK_G1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOBLK_G1 {}
impl IOBLK_G1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioblk_g10::RegisterBlock = 0x0300_1800 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioblk_g10::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for IOBLK_G1 {
    type Target = ioblk_g10::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOBLK_G1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOBLK_G1").finish()
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub use self::ioblk_g10 as ioblk_g1;
#[doc = "PINCTRL of IOBLK_G10"]
pub struct IOBLK_G7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOBLK_G7 {}
impl IOBLK_G7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioblk_g10::RegisterBlock = 0x0300_1900 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioblk_g10::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for IOBLK_G7 {
    type Target = ioblk_g10::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOBLK_G7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOBLK_G7").finish()
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub use self::ioblk_g10 as ioblk_g7;
#[doc = "PINCTRL of IOBLK_G10"]
pub struct IOBLK_G12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOBLK_G12 {}
impl IOBLK_G12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioblk_g10::RegisterBlock = 0x0300_1c00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioblk_g10::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for IOBLK_G12 {
    type Target = ioblk_g10::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOBLK_G12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOBLK_G12").finish()
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub use self::ioblk_g10 as ioblk_g12;
#[doc = "PINCTRL of IOBLK_G10"]
pub struct IOBLK_RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOBLK_RTC {}
impl IOBLK_RTC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ioblk_g10::RegisterBlock = 0x0502_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ioblk_g10::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for IOBLK_RTC {
    type Target = ioblk_g10::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOBLK_RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOBLK_RTC").finish()
    }
}
#[doc = "PINCTRL of IOBLK_G10"]
pub use self::ioblk_g10 as ioblk_rtc;
#[doc = "UART0"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0414_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "UART0"]
pub mod uart0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved_0_dll: [u8; 0x04],
        _reserved_1_dlh: [u8; 0x04],
        _reserved_2_fcr: [u8; 0x04],
        lcr: LCR,
        mcr: MCR,
        lsr: LSR,
        msr: MSR,
        _reserved7: [u8; 0x04],
        lpdll: LPDLL,
        lpdlh: LPDLH,
        _reserved9: [u8; 0x08],
        _reserved_9_srbr: [u8; 0x04],
        _reserved10: [u8; 0x3c],
        far: FAR,
        tfr: TFR,
        rfw: RFW,
        usr: USR,
        tfl: TFL,
        _reserved15: [u8; 0x04],
        srr: SRR,
        srts: SRTS,
        sbcr: SBCR,
        sdmam: SDMAM,
        sfe: SFE,
        srt: SRT,
        stet: STET,
        htx: HTX,
        dmasa: DMASA,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Divisor Latch Low"]
        #[inline(always)]
        pub const fn dll(&self) -> &DLL {
            unsafe { &*(self as *const Self).cast::<u8>().add(0).cast() }
        }
        #[doc = "0x00 - Transmitter Holding Register"]
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(0).cast() }
        }
        #[doc = "0x00 - Receiver Buffer Register"]
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(0).cast() }
        }
        #[doc = "0x04 - Divisor Latch High"]
        #[inline(always)]
        pub const fn dlh(&self) -> &DLH {
            unsafe { &*(self as *const Self).cast::<u8>().add(4).cast() }
        }
        #[doc = "0x04 - Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            unsafe { &*(self as *const Self).cast::<u8>().add(4).cast() }
        }
        #[doc = "0x08 - Interrupt Identification Register"]
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x08 - FIFO Control Register"]
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x0c - Line Control Register"]
        #[inline(always)]
        pub const fn lcr(&self) -> &LCR {
            &self.lcr
        }
        #[doc = "0x10 - Modem Control Register"]
        #[inline(always)]
        pub const fn mcr(&self) -> &MCR {
            &self.mcr
        }
        #[doc = "0x14 - Line Status Register"]
        #[inline(always)]
        pub const fn lsr(&self) -> &LSR {
            &self.lsr
        }
        #[doc = "0x18 - Modem Status Register"]
        #[inline(always)]
        pub const fn msr(&self) -> &MSR {
            &self.msr
        }
        #[doc = "0x20 - Low Power Divisor Latch Low"]
        #[inline(always)]
        pub const fn lpdll(&self) -> &LPDLL {
            &self.lpdll
        }
        #[doc = "0x24 - Low Power Divisor Latch High"]
        #[inline(always)]
        pub const fn lpdlh(&self) -> &LPDLH {
            &self.lpdlh
        }
        #[doc = "0x30 - Shadow Transmitter Holding Register"]
        #[inline(always)]
        pub const fn sthr(&self) -> &STHR {
            unsafe { &*(self as *const Self).cast::<u8>().add(48).cast() }
        }
        #[doc = "0x30 - Shadow Receiver Buffer Register"]
        #[inline(always)]
        pub const fn srbr(&self) -> &SRBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(48).cast() }
        }
        #[doc = "0x70 - FIFO Access Register"]
        #[inline(always)]
        pub const fn far(&self) -> &FAR {
            &self.far
        }
        #[doc = "0x74 - FIFO Trigger Register"]
        #[inline(always)]
        pub const fn tfr(&self) -> &TFR {
            &self.tfr
        }
        #[doc = "0x78 - FIFO RX Watermark"]
        #[inline(always)]
        pub const fn rfw(&self) -> &RFW {
            &self.rfw
        }
        #[doc = "0x7c - UART Status Register"]
        #[inline(always)]
        pub const fn usr(&self) -> &USR {
            &self.usr
        }
        #[doc = "0x80 - Transmit FIFO Level"]
        #[inline(always)]
        pub const fn tfl(&self) -> &TFL {
            &self.tfl
        }
        #[doc = "0x88 - Software Reset Register"]
        #[inline(always)]
        pub const fn srr(&self) -> &SRR {
            &self.srr
        }
        #[doc = "0x8c - Shadow Request to Send"]
        #[inline(always)]
        pub const fn srts(&self) -> &SRTS {
            &self.srts
        }
        #[doc = "0x90 - Shadow Break Control Register"]
        #[inline(always)]
        pub const fn sbcr(&self) -> &SBCR {
            &self.sbcr
        }
        #[doc = "0x94 - Shadow DMA Mode"]
        #[inline(always)]
        pub const fn sdmam(&self) -> &SDMAM {
            &self.sdmam
        }
        #[doc = "0x98 - Shadow FIFO Enable"]
        #[inline(always)]
        pub const fn sfe(&self) -> &SFE {
            &self.sfe
        }
        #[doc = "0x9c - Shadow RCVR Trigger"]
        #[inline(always)]
        pub const fn srt(&self) -> &SRT {
            &self.srt
        }
        #[doc = "0xa0 - Shadow TX Empty Trigger"]
        #[inline(always)]
        pub const fn stet(&self) -> &STET {
            &self.stet
        }
        #[doc = "0xa4 - Halt TX"]
        #[inline(always)]
        pub const fn htx(&self) -> &HTX {
            &self.htx
        }
        #[doc = "0xa8 - DMA Software Acknowledge"]
        #[inline(always)]
        pub const fn dmasa(&self) -> &DMASA {
            &self.dmasa
        }
    }
    #[doc = "RBR (rw) register accessor: Receiver Buffer Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`]
module"]
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    #[doc = "Receiver Buffer Register"]
    pub mod rbr {
        #[doc = "Register `RBR` reader"]
        pub type R = crate::R<RBR_SPEC>;
        #[doc = "Register `RBR` writer"]
        pub type W = crate::W<RBR_SPEC>;
        #[doc = "Field `RBR` reader - Received data"]
        pub type RBR_R = crate::FieldReader;
        #[doc = "Field `RBR` writer - Received data"]
        pub type RBR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Received data"]
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Received data"]
            #[inline(always)]
            #[must_use]
            pub fn rbr(&mut self) -> RBR_W<RBR_SPEC> {
                RBR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Receiver Buffer Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rbr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rbr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rbr::R`](R) reader structure"]
        impl crate::Readable for RBR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rbr::W`](W) writer structure"]
        impl crate::Writable for RBR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RBR to value 0"]
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "THR (rw) register accessor: Transmitter Holding Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`thr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`]
module"]
    pub type THR = crate::Reg<thr::THR_SPEC>;
    #[doc = "Transmitter Holding Register"]
    pub mod thr {
        #[doc = "Register `THR` reader"]
        pub type R = crate::R<THR_SPEC>;
        #[doc = "Register `THR` writer"]
        pub type W = crate::W<THR_SPEC>;
        #[doc = "Field `THR` reader - Data to be transmitted"]
        pub type THR_R = crate::FieldReader;
        #[doc = "Field `THR` writer - Data to be transmitted"]
        pub type THR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Data to be transmitted"]
            #[inline(always)]
            pub fn thr(&self) -> THR_R {
                THR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Data to be transmitted"]
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<THR_SPEC> {
                THR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Transmitter Holding Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`thr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`thr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`thr::R`](R) reader structure"]
        impl crate::Readable for THR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"]
        impl crate::Writable for THR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets THR to value 0"]
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DLL (rw) register accessor: Divisor Latch Low\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dll::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dll::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dll`]
module"]
    pub type DLL = crate::Reg<dll::DLL_SPEC>;
    #[doc = "Divisor Latch Low"]
    pub mod dll {
        #[doc = "Register `DLL` reader"]
        pub type R = crate::R<DLL_SPEC>;
        #[doc = "Register `DLL` writer"]
        pub type W = crate::W<DLL_SPEC>;
        #[doc = "Field `DLL` reader - Divisor Latch Low"]
        pub type DLL_R = crate::FieldReader;
        #[doc = "Field `DLL` writer - Divisor Latch Low"]
        pub type DLL_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Divisor Latch Low"]
            #[inline(always)]
            pub fn dll(&self) -> DLL_R {
                DLL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Divisor Latch Low"]
            #[inline(always)]
            #[must_use]
            pub fn dll(&mut self) -> DLL_W<DLL_SPEC> {
                DLL_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Divisor Latch Low\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dll::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dll::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DLL_SPEC;
        impl crate::RegisterSpec for DLL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dll::R`](R) reader structure"]
        impl crate::Readable for DLL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dll::W`](W) writer structure"]
        impl crate::Writable for DLL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DLL to value 0"]
        impl crate::Resettable for DLL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IER (rw) register accessor: Interrupt Enable Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ier::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`]
module"]
    pub type IER = crate::Reg<ier::IER_SPEC>;
    #[doc = "Interrupt Enable Register"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IER_SPEC>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IER_SPEC>;
        #[doc = "Field `ERBFI` reader - Enable Received Data Available Interrupt"]
        pub type ERBFI_R = crate::BitReader;
        #[doc = "Field `ERBFI` writer - Enable Received Data Available Interrupt"]
        pub type ERBFI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ETBEI` reader - Enable Transmitter Holding Register Empty Interrupt"]
        pub type ETBEI_R = crate::BitReader;
        #[doc = "Field `ETBEI` writer - Enable Transmitter Holding Register Empty Interrupt"]
        pub type ETBEI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ELSI` reader - Enable Receiver Line Status Interrupt"]
        pub type ELSI_R = crate::BitReader;
        #[doc = "Field `ELSI` writer - Enable Receiver Line Status Interrupt"]
        pub type ELSI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EDSSI` reader - Enable Modem Status Interrupt"]
        pub type EDSSI_R = crate::BitReader;
        #[doc = "Field `EDSSI` writer - Enable Modem Status Interrupt"]
        pub type EDSSI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EIT` reader - Programmable THRE Interrupt Mode Enable"]
        pub type EIT_R = crate::BitReader;
        #[doc = "Field `EIT` writer - Programmable THRE Interrupt Mode Enable"]
        pub type EIT_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Enable Received Data Available Interrupt"]
            #[inline(always)]
            pub fn erbfi(&self) -> ERBFI_R {
                ERBFI_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable Transmitter Holding Register Empty Interrupt"]
            #[inline(always)]
            pub fn etbei(&self) -> ETBEI_R {
                ETBEI_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Receiver Line Status Interrupt"]
            #[inline(always)]
            pub fn elsi(&self) -> ELSI_R {
                ELSI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable Modem Status Interrupt"]
            #[inline(always)]
            pub fn edssi(&self) -> EDSSI_R {
                EDSSI_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 7 - Programmable THRE Interrupt Mode Enable"]
            #[inline(always)]
            pub fn eit(&self) -> EIT_R {
                EIT_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable Received Data Available Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn erbfi(&mut self) -> ERBFI_W<IER_SPEC> {
                ERBFI_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable Transmitter Holding Register Empty Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn etbei(&mut self) -> ETBEI_W<IER_SPEC> {
                ETBEI_W::new(self, 1)
            }
            #[doc = "Bit 2 - Enable Receiver Line Status Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn elsi(&mut self) -> ELSI_W<IER_SPEC> {
                ELSI_W::new(self, 2)
            }
            #[doc = "Bit 3 - Enable Modem Status Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn edssi(&mut self) -> EDSSI_W<IER_SPEC> {
                EDSSI_W::new(self, 3)
            }
            #[doc = "Bit 7 - Programmable THRE Interrupt Mode Enable"]
            #[inline(always)]
            #[must_use]
            pub fn eit(&mut self) -> EIT_W<IER_SPEC> {
                EIT_W::new(self, 7)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Enable Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ier::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IER_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IER_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DLH (rw) register accessor: Divisor Latch High\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlh::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlh::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dlh`]
module"]
    pub type DLH = crate::Reg<dlh::DLH_SPEC>;
    #[doc = "Divisor Latch High"]
    pub mod dlh {
        #[doc = "Register `DLH` reader"]
        pub type R = crate::R<DLH_SPEC>;
        #[doc = "Register `DLH` writer"]
        pub type W = crate::W<DLH_SPEC>;
        #[doc = "Field `DLH` reader - Divisor Latch High"]
        pub type DLH_R = crate::FieldReader;
        #[doc = "Field `DLH` writer - Divisor Latch High"]
        pub type DLH_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Divisor Latch High"]
            #[inline(always)]
            pub fn dlh(&self) -> DLH_R {
                DLH_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Divisor Latch High"]
            #[inline(always)]
            #[must_use]
            pub fn dlh(&mut self) -> DLH_W<DLH_SPEC> {
                DLH_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Divisor Latch High\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dlh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dlh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DLH_SPEC;
        impl crate::RegisterSpec for DLH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dlh::R`](R) reader structure"]
        impl crate::Readable for DLH_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dlh::W`](W) writer structure"]
        impl crate::Writable for DLH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DLH to value 0"]
        impl crate::Resettable for DLH_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FCR (rw) register accessor: FIFO Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`]
module"]
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    #[doc = "FIFO Control Register"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FCR_SPEC>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FCR_SPEC>;
        #[doc = "Field `FIFOEN` reader - FIFO Enable"]
        pub type FIFOEN_R = crate::BitReader;
        #[doc = "Field `FIFOEN` writer - FIFO Enable"]
        pub type FIFOEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RXFIFORST` reader - RX FIFO Reset"]
        pub type RXFIFORST_R = crate::BitReader;
        #[doc = "Field `RXFIFORST` writer - RX FIFO Reset"]
        pub type RXFIFORST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXFIFORST` reader - TX FIFO Reset"]
        pub type TXFIFORST_R = crate::BitReader;
        #[doc = "Field `TXFIFORST` writer - TX FIFO Reset"]
        pub type TXFIFORST_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DMAMODE` reader - DMA Mode"]
        pub type DMAMODE_R = crate::BitReader;
        #[doc = "Field `DMAMODE` writer - DMA Mode"]
        pub type DMAMODE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TXEMPTYTRIG` reader - TX Empty Trigger"]
        pub type TXEMPTYTRIG_R = crate::FieldReader;
        #[doc = "Field `TXEMPTYTRIG` writer - TX Empty Trigger"]
        pub type TXEMPTYTRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `RXTRIG` reader - RX Trigger"]
        pub type RXTRIG_R = crate::FieldReader;
        #[doc = "Field `RXTRIG` writer - RX Trigger"]
        pub type RXTRIG_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - FIFO Enable"]
            #[inline(always)]
            pub fn fifoen(&self) -> FIFOEN_R {
                FIFOEN_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RX FIFO Reset"]
            #[inline(always)]
            pub fn rxfiforst(&self) -> RXFIFORST_R {
                RXFIFORST_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - TX FIFO Reset"]
            #[inline(always)]
            pub fn txfiforst(&self) -> TXFIFORST_R {
                TXFIFORST_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - DMA Mode"]
            #[inline(always)]
            pub fn dmamode(&self) -> DMAMODE_R {
                DMAMODE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - TX Empty Trigger"]
            #[inline(always)]
            pub fn txemptytrig(&self) -> TXEMPTYTRIG_R {
                TXEMPTYTRIG_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - RX Trigger"]
            #[inline(always)]
            pub fn rxtrig(&self) -> RXTRIG_R {
                RXTRIG_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - FIFO Enable"]
            #[inline(always)]
            #[must_use]
            pub fn fifoen(&mut self) -> FIFOEN_W<FCR_SPEC> {
                FIFOEN_W::new(self, 0)
            }
            #[doc = "Bit 1 - RX FIFO Reset"]
            #[inline(always)]
            #[must_use]
            pub fn rxfiforst(&mut self) -> RXFIFORST_W<FCR_SPEC> {
                RXFIFORST_W::new(self, 1)
            }
            #[doc = "Bit 2 - TX FIFO Reset"]
            #[inline(always)]
            #[must_use]
            pub fn txfiforst(&mut self) -> TXFIFORST_W<FCR_SPEC> {
                TXFIFORST_W::new(self, 2)
            }
            #[doc = "Bit 3 - DMA Mode"]
            #[inline(always)]
            #[must_use]
            pub fn dmamode(&mut self) -> DMAMODE_W<FCR_SPEC> {
                DMAMODE_W::new(self, 3)
            }
            #[doc = "Bits 4:5 - TX Empty Trigger"]
            #[inline(always)]
            #[must_use]
            pub fn txemptytrig(&mut self) -> TXEMPTYTRIG_W<FCR_SPEC> {
                TXEMPTYTRIG_W::new(self, 4)
            }
            #[doc = "Bits 6:7 - RX Trigger"]
            #[inline(always)]
            #[must_use]
            pub fn rxtrig(&mut self) -> RXTRIG_W<FCR_SPEC> {
                RXTRIG_W::new(self, 6)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "IIR (rw) register accessor: Interrupt Identification Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iir::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iir::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`]
module"]
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    #[doc = "Interrupt Identification Register"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IIR_SPEC>;
        #[doc = "Register `IIR` writer"]
        pub type W = crate::W<IIR_SPEC>;
        #[doc = "Field `INTRID` reader - Interrupt ID"]
        pub type INTRID_R = crate::FieldReader;
        #[doc = "Field `INTRID` writer - Interrupt ID"]
        pub type INTRID_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `FIFOEN` reader - FIFOs Enabled"]
        pub type FIFOEN_R = crate::FieldReader;
        #[doc = "Field `FIFOEN` writer - FIFOs Enabled"]
        pub type FIFOEN_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:3 - Interrupt ID"]
            #[inline(always)]
            pub fn intrid(&self) -> INTRID_R {
                INTRID_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 6:7 - FIFOs Enabled"]
            #[inline(always)]
            pub fn fifoen(&self) -> FIFOEN_R {
                FIFOEN_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Interrupt ID"]
            #[inline(always)]
            #[must_use]
            pub fn intrid(&mut self) -> INTRID_W<IIR_SPEC> {
                INTRID_W::new(self, 0)
            }
            #[doc = "Bits 6:7 - FIFOs Enabled"]
            #[inline(always)]
            #[must_use]
            pub fn fifoen(&mut self) -> FIFOEN_W<IIR_SPEC> {
                FIFOEN_W::new(self, 6)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Identification Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`iir::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`iir::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IIR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`iir::W`](W) writer structure"]
        impl crate::Writable for IIR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets IIR to value 0"]
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LCR (rw) register accessor: Line Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`]
module"]
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    #[doc = "Line Control Register"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LCR_SPEC>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LCR_SPEC>;
        #[doc = "Field `WLS` reader - Word Length Select"]
        pub type WLS_R = crate::FieldReader;
        #[doc = "Field `WLS` writer - Word Length Select"]
        pub type WLS_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `STB` reader - Number of Stop Bits"]
        pub type STB_R = crate::BitReader;
        #[doc = "Field `STB` writer - Number of Stop Bits"]
        pub type STB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PEN` reader - Parity Enable"]
        pub type PEN_R = crate::BitReader;
        #[doc = "Field `PEN` writer - Parity Enable"]
        pub type PEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EPS` reader - Even Parity Select"]
        pub type EPS_R = crate::BitReader;
        #[doc = "Field `EPS` writer - Even Parity Select"]
        pub type EPS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STICKPAR` reader - Stick Parity"]
        pub type STICKPAR_R = crate::BitReader;
        #[doc = "Field `STICKPAR` writer - Stick Parity"]
        pub type STICKPAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BRK` reader - Break Control"]
        pub type BRK_R = crate::BitReader;
        #[doc = "Field `BRK` writer - Break Control"]
        pub type BRK_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DLAB` reader - Divisor Latch Access Bit"]
        pub type DLAB_R = crate::BitReader;
        #[doc = "Field `DLAB` writer - Divisor Latch Access Bit"]
        pub type DLAB_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline(always)]
            pub fn wls(&self) -> WLS_R {
                WLS_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Number of Stop Bits"]
            #[inline(always)]
            pub fn stb(&self) -> STB_R {
                STB_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            pub fn pen(&self) -> PEN_R {
                PEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Even Parity Select"]
            #[inline(always)]
            pub fn eps(&self) -> EPS_R {
                EPS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Stick Parity"]
            #[inline(always)]
            pub fn stickpar(&self) -> STICKPAR_R {
                STICKPAR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Break Control"]
            #[inline(always)]
            pub fn brk(&self) -> BRK_R {
                BRK_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit"]
            #[inline(always)]
            pub fn dlab(&self) -> DLAB_R {
                DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline(always)]
            #[must_use]
            pub fn wls(&mut self) -> WLS_W<LCR_SPEC> {
                WLS_W::new(self, 0)
            }
            #[doc = "Bit 2 - Number of Stop Bits"]
            #[inline(always)]
            #[must_use]
            pub fn stb(&mut self) -> STB_W<LCR_SPEC> {
                STB_W::new(self, 2)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            #[must_use]
            pub fn pen(&mut self) -> PEN_W<LCR_SPEC> {
                PEN_W::new(self, 3)
            }
            #[doc = "Bit 4 - Even Parity Select"]
            #[inline(always)]
            #[must_use]
            pub fn eps(&mut self) -> EPS_W<LCR_SPEC> {
                EPS_W::new(self, 4)
            }
            #[doc = "Bit 5 - Stick Parity"]
            #[inline(always)]
            #[must_use]
            pub fn stickpar(&mut self) -> STICKPAR_W<LCR_SPEC> {
                STICKPAR_W::new(self, 5)
            }
            #[doc = "Bit 6 - Break Control"]
            #[inline(always)]
            #[must_use]
            pub fn brk(&mut self) -> BRK_W<LCR_SPEC> {
                BRK_W::new(self, 6)
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit"]
            #[inline(always)]
            #[must_use]
            pub fn dlab(&mut self) -> DLAB_W<LCR_SPEC> {
                DLAB_W::new(self, 7)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Line Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MCR (rw) register accessor: Modem Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`]
module"]
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    #[doc = "Modem Control Register"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<MCR_SPEC>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<MCR_SPEC>;
        #[doc = "Field `RTS` reader - Request to Send"]
        pub type RTS_R = crate::BitReader;
        #[doc = "Field `RTS` writer - Request to Send"]
        pub type RTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AFCE` reader - Auto Flow Control Enable"]
        pub type AFCE_R = crate::BitReader;
        #[doc = "Field `AFCE` writer - Auto Flow Control Enable"]
        pub type AFCE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 6 - Auto Flow Control Enable"]
            #[inline(always)]
            pub fn afce(&self) -> AFCE_R {
                AFCE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<MCR_SPEC> {
                RTS_W::new(self, 1)
            }
            #[doc = "Bit 6 - Auto Flow Control Enable"]
            #[inline(always)]
            #[must_use]
            pub fn afce(&mut self) -> AFCE_W<MCR_SPEC> {
                AFCE_W::new(self, 6)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Modem Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`mcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for MCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for MCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LSR (rw) register accessor: Line Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lsr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`]
module"]
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    #[doc = "Line Status Register"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LSR_SPEC>;
        #[doc = "Register `LSR` writer"]
        pub type W = crate::W<LSR_SPEC>;
        #[doc = "Field `DR` reader - Data Ready"]
        pub type DR_R = crate::BitReader;
        #[doc = "Field `DR` writer - Data Ready"]
        pub type DR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OE` reader - Overrun Error"]
        pub type OE_R = crate::BitReader;
        #[doc = "Field `OE` writer - Overrun Error"]
        pub type OE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PE` reader - Parity Error"]
        pub type PE_R = crate::BitReader;
        #[doc = "Field `PE` writer - Parity Error"]
        pub type PE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FE` reader - Framing Error"]
        pub type FE_R = crate::BitReader;
        #[doc = "Field `FE` writer - Framing Error"]
        pub type FE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BI` reader - Break Interrupt"]
        pub type BI_R = crate::BitReader;
        #[doc = "Field `BI` writer - Break Interrupt"]
        pub type BI_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `THRE` reader - "]
        pub type THRE_R = crate::BitReader;
        #[doc = "Field `THRE` writer - "]
        pub type THRE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Data Ready"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Overrun Error"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Parity Error"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Framing Error"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Break Interrupt"]
            #[inline(always)]
            pub fn bi(&self) -> BI_R {
                BI_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn thre(&self) -> THRE_R {
                THRE_R::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data Ready"]
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<LSR_SPEC> {
                DR_W::new(self, 0)
            }
            #[doc = "Bit 1 - Overrun Error"]
            #[inline(always)]
            #[must_use]
            pub fn oe(&mut self) -> OE_W<LSR_SPEC> {
                OE_W::new(self, 1)
            }
            #[doc = "Bit 2 - Parity Error"]
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<LSR_SPEC> {
                PE_W::new(self, 2)
            }
            #[doc = "Bit 3 - Framing Error"]
            #[inline(always)]
            #[must_use]
            pub fn fe(&mut self) -> FE_W<LSR_SPEC> {
                FE_W::new(self, 3)
            }
            #[doc = "Bit 4 - Break Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn bi(&mut self) -> BI_W<LSR_SPEC> {
                BI_W::new(self, 4)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            #[must_use]
            pub fn thre(&mut self) -> THRE_W<LSR_SPEC> {
                THRE_W::new(self, 5)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Line Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lsr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lsr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LSR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lsr::W`](W) writer structure"]
        impl crate::Writable for LSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LSR to value 0"]
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "MSR (rw) register accessor: Modem Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`msr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`msr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@msr`]
module"]
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    #[doc = "Modem Status Register"]
    pub mod msr {
        #[doc = "Register `MSR` reader"]
        pub type R = crate::R<MSR_SPEC>;
        #[doc = "Register `MSR` writer"]
        pub type W = crate::W<MSR_SPEC>;
        #[doc = "Field `DSR` reader - Data Clear to Send"]
        pub type DSR_R = crate::BitReader;
        #[doc = "Field `DSR` writer - Data Clear to Send"]
        pub type DSR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CTS` reader - Clear to Send"]
        pub type CTS_R = crate::BitReader;
        #[doc = "Field `CTS` writer - Clear to Send"]
        pub type CTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Data Clear to Send"]
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 4 - Clear to Send"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data Clear to Send"]
            #[inline(always)]
            #[must_use]
            pub fn dsr(&mut self) -> DSR_W<MSR_SPEC> {
                DSR_W::new(self, 0)
            }
            #[doc = "Bit 4 - Clear to Send"]
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<MSR_SPEC> {
                CTS_W::new(self, 4)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Modem Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`msr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`msr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`msr::R`](R) reader structure"]
        impl crate::Readable for MSR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`msr::W`](W) writer structure"]
        impl crate::Writable for MSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets MSR to value 0"]
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LPDLL (rw) register accessor: Low Power Divisor Latch Low\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lpdll::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lpdll::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lpdll`]
module"]
    pub type LPDLL = crate::Reg<lpdll::LPDLL_SPEC>;
    #[doc = "Low Power Divisor Latch Low"]
    pub mod lpdll {
        #[doc = "Register `LPDLL` reader"]
        pub type R = crate::R<LPDLL_SPEC>;
        #[doc = "Register `LPDLL` writer"]
        pub type W = crate::W<LPDLL_SPEC>;
        #[doc = "Field `LPDLL` reader - "]
        pub type LPDLL_R = crate::FieldReader;
        #[doc = "Field `LPDLL` writer - "]
        pub type LPDLL_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn lpdll(&self) -> LPDLL_R {
                LPDLL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn lpdll(&mut self) -> LPDLL_W<LPDLL_SPEC> {
                LPDLL_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Low Power Divisor Latch Low\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lpdll::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lpdll::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LPDLL_SPEC;
        impl crate::RegisterSpec for LPDLL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lpdll::R`](R) reader structure"]
        impl crate::Readable for LPDLL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lpdll::W`](W) writer structure"]
        impl crate::Writable for LPDLL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LPDLL to value 0"]
        impl crate::Resettable for LPDLL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LPDLH (rw) register accessor: Low Power Divisor Latch High\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lpdlh::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lpdlh::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lpdlh`]
module"]
    pub type LPDLH = crate::Reg<lpdlh::LPDLH_SPEC>;
    #[doc = "Low Power Divisor Latch High"]
    pub mod lpdlh {
        #[doc = "Register `LPDLH` reader"]
        pub type R = crate::R<LPDLH_SPEC>;
        #[doc = "Register `LPDLH` writer"]
        pub type W = crate::W<LPDLH_SPEC>;
        #[doc = "Field `LPDLH` reader - "]
        pub type LPDLH_R = crate::FieldReader;
        #[doc = "Field `LPDLH` writer - "]
        pub type LPDLH_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn lpdlh(&self) -> LPDLH_R {
                LPDLH_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn lpdlh(&mut self) -> LPDLH_W<LPDLH_SPEC> {
                LPDLH_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Low Power Divisor Latch High\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`lpdlh::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`lpdlh::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LPDLH_SPEC;
        impl crate::RegisterSpec for LPDLH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`lpdlh::R`](R) reader structure"]
        impl crate::Readable for LPDLH_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`lpdlh::W`](W) writer structure"]
        impl crate::Writable for LPDLH_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LPDLH to value 0"]
        impl crate::Resettable for LPDLH_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRBR (rw) register accessor: Shadow Receiver Buffer Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srbr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srbr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srbr`]
module"]
    pub type SRBR = crate::Reg<srbr::SRBR_SPEC>;
    #[doc = "Shadow Receiver Buffer Register"]
    pub mod srbr {
        #[doc = "Register `SRBR` reader"]
        pub type R = crate::R<SRBR_SPEC>;
        #[doc = "Register `SRBR` writer"]
        pub type W = crate::W<SRBR_SPEC>;
        #[doc = "Field `SRBR` reader - "]
        pub type SRBR_R = crate::FieldReader;
        #[doc = "Field `SRBR` writer - "]
        pub type SRBR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn srbr(&self) -> SRBR_R {
                SRBR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn srbr(&mut self) -> SRBR_W<SRBR_SPEC> {
                SRBR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow Receiver Buffer Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srbr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srbr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SRBR_SPEC;
        impl crate::RegisterSpec for SRBR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srbr::R`](R) reader structure"]
        impl crate::Readable for SRBR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`srbr::W`](W) writer structure"]
        impl crate::Writable for SRBR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRBR to value 0"]
        impl crate::Resettable for SRBR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STHR (rw) register accessor: Shadow Transmitter Holding Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sthr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sthr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sthr`]
module"]
    pub type STHR = crate::Reg<sthr::STHR_SPEC>;
    #[doc = "Shadow Transmitter Holding Register"]
    pub mod sthr {
        #[doc = "Register `STHR` reader"]
        pub type R = crate::R<STHR_SPEC>;
        #[doc = "Register `STHR` writer"]
        pub type W = crate::W<STHR_SPEC>;
        #[doc = "Field `STHR` reader - "]
        pub type STHR_R = crate::FieldReader;
        #[doc = "Field `STHR` writer - "]
        pub type STHR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn sthr(&self) -> STHR_R {
                STHR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn sthr(&mut self) -> STHR_W<STHR_SPEC> {
                STHR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow Transmitter Holding Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sthr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sthr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STHR_SPEC;
        impl crate::RegisterSpec for STHR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sthr::R`](R) reader structure"]
        impl crate::Readable for STHR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sthr::W`](W) writer structure"]
        impl crate::Writable for STHR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STHR to value 0"]
        impl crate::Resettable for STHR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FAR (rw) register accessor: FIFO Access Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`far::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`far::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@far`]
module"]
    pub type FAR = crate::Reg<far::FAR_SPEC>;
    #[doc = "FIFO Access Register"]
    pub mod far {
        #[doc = "Register `FAR` reader"]
        pub type R = crate::R<FAR_SPEC>;
        #[doc = "Register `FAR` writer"]
        pub type W = crate::W<FAR_SPEC>;
        #[doc = "Field `FAR` reader - "]
        pub type FAR_R = crate::FieldReader;
        #[doc = "Field `FAR` writer - "]
        pub type FAR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn far(&self) -> FAR_R {
                FAR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn far(&mut self) -> FAR_W<FAR_SPEC> {
                FAR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO Access Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`far::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`far::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FAR_SPEC;
        impl crate::RegisterSpec for FAR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`far::R`](R) reader structure"]
        impl crate::Readable for FAR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`far::W`](W) writer structure"]
        impl crate::Writable for FAR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FAR to value 0"]
        impl crate::Resettable for FAR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TFR (rw) register accessor: FIFO Trigger Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tfr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tfr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfr`]
module"]
    pub type TFR = crate::Reg<tfr::TFR_SPEC>;
    #[doc = "FIFO Trigger Register"]
    pub mod tfr {
        #[doc = "Register `TFR` reader"]
        pub type R = crate::R<TFR_SPEC>;
        #[doc = "Register `TFR` writer"]
        pub type W = crate::W<TFR_SPEC>;
        #[doc = "Field `TFR` reader - "]
        pub type TFR_R = crate::FieldReader;
        #[doc = "Field `TFR` writer - "]
        pub type TFR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn tfr(&self) -> TFR_R {
                TFR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn tfr(&mut self) -> TFR_W<TFR_SPEC> {
                TFR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO Trigger Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tfr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tfr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TFR_SPEC;
        impl crate::RegisterSpec for TFR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tfr::R`](R) reader structure"]
        impl crate::Readable for TFR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tfr::W`](W) writer structure"]
        impl crate::Writable for TFR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TFR to value 0"]
        impl crate::Resettable for TFR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RFW (rw) register accessor: FIFO RX Watermark\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rfw::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfw::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfw`]
module"]
    pub type RFW = crate::Reg<rfw::RFW_SPEC>;
    #[doc = "FIFO RX Watermark"]
    pub mod rfw {
        #[doc = "Register `RFW` reader"]
        pub type R = crate::R<RFW_SPEC>;
        #[doc = "Register `RFW` writer"]
        pub type W = crate::W<RFW_SPEC>;
        #[doc = "Field `RFW` reader - Receive FIFO Write Data"]
        pub type RFW_R = crate::FieldReader;
        #[doc = "Field `RFW` writer - Receive FIFO Write Data"]
        pub type RFW_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `RPE` reader - Receive FIFO Parity Error"]
        pub type RPE_R = crate::BitReader;
        #[doc = "Field `RPE` writer - Receive FIFO Parity Error"]
        pub type RPE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RFE` reader - Receive FIFO Frame Error"]
        pub type RFE_R = crate::BitReader;
        #[doc = "Field `RFE` writer - Receive FIFO Frame Error"]
        pub type RFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:7 - Receive FIFO Write Data"]
            #[inline(always)]
            pub fn rfw(&self) -> RFW_R {
                RFW_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - Receive FIFO Parity Error"]
            #[inline(always)]
            pub fn rpe(&self) -> RPE_R {
                RPE_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Receive FIFO Frame Error"]
            #[inline(always)]
            pub fn rfe(&self) -> RFE_R {
                RFE_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Receive FIFO Write Data"]
            #[inline(always)]
            #[must_use]
            pub fn rfw(&mut self) -> RFW_W<RFW_SPEC> {
                RFW_W::new(self, 0)
            }
            #[doc = "Bit 8 - Receive FIFO Parity Error"]
            #[inline(always)]
            #[must_use]
            pub fn rpe(&mut self) -> RPE_W<RFW_SPEC> {
                RPE_W::new(self, 8)
            }
            #[doc = "Bit 9 - Receive FIFO Frame Error"]
            #[inline(always)]
            #[must_use]
            pub fn rfe(&mut self) -> RFE_W<RFW_SPEC> {
                RFE_W::new(self, 9)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO RX Watermark\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rfw::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rfw::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RFW_SPEC;
        impl crate::RegisterSpec for RFW_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rfw::R`](R) reader structure"]
        impl crate::Readable for RFW_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rfw::W`](W) writer structure"]
        impl crate::Writable for RFW_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RFW to value 0"]
        impl crate::Resettable for RFW_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "USR (rw) register accessor: UART Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`usr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usr`]
module"]
    pub type USR = crate::Reg<usr::USR_SPEC>;
    #[doc = "UART Status Register"]
    pub mod usr {
        #[doc = "Register `USR` reader"]
        pub type R = crate::R<USR_SPEC>;
        #[doc = "Register `USR` writer"]
        pub type W = crate::W<USR_SPEC>;
        #[doc = "Field `BUSY` reader - UART Busy"]
        pub type BUSY_R = crate::BitReader;
        #[doc = "Field `BUSY` writer - UART Busy"]
        pub type BUSY_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TFNF` reader - Transmit FIFO Not Full"]
        pub type TFNF_R = crate::BitReader;
        #[doc = "Field `TFNF` writer - Transmit FIFO Not Full"]
        pub type TFNF_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TFE` reader - Transmit FIFO Empty"]
        pub type TFE_R = crate::BitReader;
        #[doc = "Field `TFE` writer - Transmit FIFO Empty"]
        pub type TFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RFNE` reader - Receive FIFO Not Empty"]
        pub type RFNE_R = crate::BitReader;
        #[doc = "Field `RFNE` writer - Receive FIFO Not Empty"]
        pub type RFNE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RFF` reader - Receive FIFO Full"]
        pub type RFF_R = crate::BitReader;
        #[doc = "Field `RFF` writer - Receive FIFO Full"]
        pub type RFF_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - UART Busy"]
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Transmit FIFO Not Full"]
            #[inline(always)]
            pub fn tfnf(&self) -> TFNF_R {
                TFNF_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Transmit FIFO Empty"]
            #[inline(always)]
            pub fn tfe(&self) -> TFE_R {
                TFE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Receive FIFO Not Empty"]
            #[inline(always)]
            pub fn rfne(&self) -> RFNE_R {
                RFNE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Receive FIFO Full"]
            #[inline(always)]
            pub fn rff(&self) -> RFF_R {
                RFF_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - UART Busy"]
            #[inline(always)]
            #[must_use]
            pub fn busy(&mut self) -> BUSY_W<USR_SPEC> {
                BUSY_W::new(self, 0)
            }
            #[doc = "Bit 1 - Transmit FIFO Not Full"]
            #[inline(always)]
            #[must_use]
            pub fn tfnf(&mut self) -> TFNF_W<USR_SPEC> {
                TFNF_W::new(self, 1)
            }
            #[doc = "Bit 2 - Transmit FIFO Empty"]
            #[inline(always)]
            #[must_use]
            pub fn tfe(&mut self) -> TFE_W<USR_SPEC> {
                TFE_W::new(self, 2)
            }
            #[doc = "Bit 3 - Receive FIFO Not Empty"]
            #[inline(always)]
            #[must_use]
            pub fn rfne(&mut self) -> RFNE_W<USR_SPEC> {
                RFNE_W::new(self, 3)
            }
            #[doc = "Bit 4 - Receive FIFO Full"]
            #[inline(always)]
            #[must_use]
            pub fn rff(&mut self) -> RFF_W<USR_SPEC> {
                RFF_W::new(self, 4)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "UART Status Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`usr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`usr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct USR_SPEC;
        impl crate::RegisterSpec for USR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`usr::R`](R) reader structure"]
        impl crate::Readable for USR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`usr::W`](W) writer structure"]
        impl crate::Writable for USR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets USR to value 0"]
        impl crate::Resettable for USR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TFL (rw) register accessor: Transmit FIFO Level\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tfl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tfl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfl`]
module"]
    pub type TFL = crate::Reg<tfl::TFL_SPEC>;
    #[doc = "Transmit FIFO Level"]
    pub mod tfl {
        #[doc = "Register `TFL` reader"]
        pub type R = crate::R<TFL_SPEC>;
        #[doc = "Register `TFL` writer"]
        pub type W = crate::W<TFL_SPEC>;
        #[doc = "Field `TFL` reader - "]
        pub type TFL_R = crate::FieldReader;
        #[doc = "Field `TFL` writer - "]
        pub type TFL_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn tfl(&self) -> TFL_R {
                TFL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn tfl(&mut self) -> TFL_W<TFL_SPEC> {
                TFL_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Transmit FIFO Level\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`tfl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`tfl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TFL_SPEC;
        impl crate::RegisterSpec for TFL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`tfl::R`](R) reader structure"]
        impl crate::Readable for TFL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`tfl::W`](W) writer structure"]
        impl crate::Writable for TFL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TFL to value 0"]
        impl crate::Resettable for TFL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRR (rw) register accessor: Software Reset Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srr`]
module"]
    pub type SRR = crate::Reg<srr::SRR_SPEC>;
    #[doc = "Software Reset Register"]
    pub mod srr {
        #[doc = "Register `SRR` reader"]
        pub type R = crate::R<SRR_SPEC>;
        #[doc = "Register `SRR` writer"]
        pub type W = crate::W<SRR_SPEC>;
        #[doc = "Field `SRR` reader - "]
        pub type SRR_R = crate::FieldReader;
        #[doc = "Field `SRR` writer - "]
        pub type SRR_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn srr(&self) -> SRR_R {
                SRR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn srr(&mut self) -> SRR_W<SRR_SPEC> {
                SRR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Software Reset Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SRR_SPEC;
        impl crate::RegisterSpec for SRR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srr::R`](R) reader structure"]
        impl crate::Readable for SRR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`srr::W`](W) writer structure"]
        impl crate::Writable for SRR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRR to value 0"]
        impl crate::Resettable for SRR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRTS (rw) register accessor: Shadow Request to Send\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srts::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srts::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srts`]
module"]
    pub type SRTS = crate::Reg<srts::SRTS_SPEC>;
    #[doc = "Shadow Request to Send"]
    pub mod srts {
        #[doc = "Register `SRTS` reader"]
        pub type R = crate::R<SRTS_SPEC>;
        #[doc = "Register `SRTS` writer"]
        pub type W = crate::W<SRTS_SPEC>;
        #[doc = "Field `SRTS` reader - "]
        pub type SRTS_R = crate::BitReader;
        #[doc = "Field `SRTS` writer - "]
        pub type SRTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn srts(&self) -> SRTS_R {
                SRTS_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn srts(&mut self) -> SRTS_W<SRTS_SPEC> {
                SRTS_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow Request to Send\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srts::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srts::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SRTS_SPEC;
        impl crate::RegisterSpec for SRTS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srts::R`](R) reader structure"]
        impl crate::Readable for SRTS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`srts::W`](W) writer structure"]
        impl crate::Writable for SRTS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRTS to value 0"]
        impl crate::Resettable for SRTS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SBCR (rw) register accessor: Shadow Break Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sbcr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sbcr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sbcr`]
module"]
    pub type SBCR = crate::Reg<sbcr::SBCR_SPEC>;
    #[doc = "Shadow Break Control Register"]
    pub mod sbcr {
        #[doc = "Register `SBCR` reader"]
        pub type R = crate::R<SBCR_SPEC>;
        #[doc = "Register `SBCR` writer"]
        pub type W = crate::W<SBCR_SPEC>;
        #[doc = "Field `SBCR` reader - "]
        pub type SBCR_R = crate::BitReader;
        #[doc = "Field `SBCR` writer - "]
        pub type SBCR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn sbcr(&self) -> SBCR_R {
                SBCR_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn sbcr(&mut self) -> SBCR_W<SBCR_SPEC> {
                SBCR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow Break Control Register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sbcr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sbcr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SBCR_SPEC;
        impl crate::RegisterSpec for SBCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sbcr::R`](R) reader structure"]
        impl crate::Readable for SBCR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sbcr::W`](W) writer structure"]
        impl crate::Writable for SBCR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SBCR to value 0"]
        impl crate::Resettable for SBCR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SDMAM (rw) register accessor: Shadow DMA Mode\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sdmam::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sdmam::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sdmam`]
module"]
    pub type SDMAM = crate::Reg<sdmam::SDMAM_SPEC>;
    #[doc = "Shadow DMA Mode"]
    pub mod sdmam {
        #[doc = "Register `SDMAM` reader"]
        pub type R = crate::R<SDMAM_SPEC>;
        #[doc = "Register `SDMAM` writer"]
        pub type W = crate::W<SDMAM_SPEC>;
        #[doc = "Field `SDMAM` reader - "]
        pub type SDMAM_R = crate::BitReader;
        #[doc = "Field `SDMAM` writer - "]
        pub type SDMAM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn sdmam(&self) -> SDMAM_R {
                SDMAM_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn sdmam(&mut self) -> SDMAM_W<SDMAM_SPEC> {
                SDMAM_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow DMA Mode\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sdmam::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sdmam::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SDMAM_SPEC;
        impl crate::RegisterSpec for SDMAM_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sdmam::R`](R) reader structure"]
        impl crate::Readable for SDMAM_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sdmam::W`](W) writer structure"]
        impl crate::Writable for SDMAM_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SDMAM to value 0"]
        impl crate::Resettable for SDMAM_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SFE (rw) register accessor: Shadow FIFO Enable\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sfe::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sfe::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sfe`]
module"]
    pub type SFE = crate::Reg<sfe::SFE_SPEC>;
    #[doc = "Shadow FIFO Enable"]
    pub mod sfe {
        #[doc = "Register `SFE` reader"]
        pub type R = crate::R<SFE_SPEC>;
        #[doc = "Register `SFE` writer"]
        pub type W = crate::W<SFE_SPEC>;
        #[doc = "Field `SFE` reader - "]
        pub type SFE_R = crate::BitReader;
        #[doc = "Field `SFE` writer - "]
        pub type SFE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn sfe(&self) -> SFE_R {
                SFE_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn sfe(&mut self) -> SFE_W<SFE_SPEC> {
                SFE_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow FIFO Enable\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`sfe::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`sfe::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SFE_SPEC;
        impl crate::RegisterSpec for SFE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sfe::R`](R) reader structure"]
        impl crate::Readable for SFE_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`sfe::W`](W) writer structure"]
        impl crate::Writable for SFE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SFE to value 0"]
        impl crate::Resettable for SFE_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "SRT (rw) register accessor: Shadow RCVR Trigger\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@srt`]
module"]
    pub type SRT = crate::Reg<srt::SRT_SPEC>;
    #[doc = "Shadow RCVR Trigger"]
    pub mod srt {
        #[doc = "Register `SRT` reader"]
        pub type R = crate::R<SRT_SPEC>;
        #[doc = "Register `SRT` writer"]
        pub type W = crate::W<SRT_SPEC>;
        #[doc = "Field `SRT` reader - "]
        pub type SRT_R = crate::FieldReader;
        #[doc = "Field `SRT` writer - "]
        pub type SRT_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn srt(&self) -> SRT_R {
                SRT_R::new((self.bits & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            #[must_use]
            pub fn srt(&mut self) -> SRT_W<SRT_SPEC> {
                SRT_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow RCVR Trigger\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`srt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`srt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SRT_SPEC;
        impl crate::RegisterSpec for SRT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`srt::R`](R) reader structure"]
        impl crate::Readable for SRT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`srt::W`](W) writer structure"]
        impl crate::Writable for SRT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets SRT to value 0"]
        impl crate::Resettable for SRT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STET (rw) register accessor: Shadow TX Empty Trigger\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stet::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stet::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stet`]
module"]
    pub type STET = crate::Reg<stet::STET_SPEC>;
    #[doc = "Shadow TX Empty Trigger"]
    pub mod stet {
        #[doc = "Register `STET` reader"]
        pub type R = crate::R<STET_SPEC>;
        #[doc = "Register `STET` writer"]
        pub type W = crate::W<STET_SPEC>;
        #[doc = "Field `STET` reader - "]
        pub type STET_R = crate::FieldReader;
        #[doc = "Field `STET` writer - "]
        pub type STET_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn stet(&self) -> STET_R {
                STET_R::new((self.bits & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            #[must_use]
            pub fn stet(&mut self) -> STET_W<STET_SPEC> {
                STET_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Shadow TX Empty Trigger\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`stet::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`stet::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STET_SPEC;
        impl crate::RegisterSpec for STET_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`stet::R`](R) reader structure"]
        impl crate::Readable for STET_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`stet::W`](W) writer structure"]
        impl crate::Writable for STET_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets STET to value 0"]
        impl crate::Resettable for STET_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "HTX (rw) register accessor: Halt TX\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`htx::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`htx::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@htx`]
module"]
    pub type HTX = crate::Reg<htx::HTX_SPEC>;
    #[doc = "Halt TX"]
    pub mod htx {
        #[doc = "Register `HTX` reader"]
        pub type R = crate::R<HTX_SPEC>;
        #[doc = "Register `HTX` writer"]
        pub type W = crate::W<HTX_SPEC>;
        #[doc = "Field `HTX` reader - "]
        pub type HTX_R = crate::BitReader;
        #[doc = "Field `HTX` writer - "]
        pub type HTX_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn htx(&self) -> HTX_R {
                HTX_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn htx(&mut self) -> HTX_W<HTX_SPEC> {
                HTX_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Halt TX\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`htx::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`htx::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HTX_SPEC;
        impl crate::RegisterSpec for HTX_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`htx::R`](R) reader structure"]
        impl crate::Readable for HTX_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`htx::W`](W) writer structure"]
        impl crate::Writable for HTX_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets HTX to value 0"]
        impl crate::Resettable for HTX_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DMASA (rw) register accessor: DMA Software Acknowledge\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmasa::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmasa::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmasa`]
module"]
    pub type DMASA = crate::Reg<dmasa::DMASA_SPEC>;
    #[doc = "DMA Software Acknowledge"]
    pub mod dmasa {
        #[doc = "Register `DMASA` reader"]
        pub type R = crate::R<DMASA_SPEC>;
        #[doc = "Register `DMASA` writer"]
        pub type W = crate::W<DMASA_SPEC>;
        #[doc = "Field `DMASA` reader - "]
        pub type DMASA_R = crate::BitReader;
        #[doc = "Field `DMASA` writer - "]
        pub type DMASA_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn dmasa(&self) -> DMASA_R {
                DMASA_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn dmasa(&mut self) -> DMASA_W<DMASA_SPEC> {
                DMASA_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "DMA Software Acknowledge\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dmasa::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dmasa::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DMASA_SPEC;
        impl crate::RegisterSpec for DMASA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dmasa::R`](R) reader structure"]
        impl crate::Readable for DMASA_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dmasa::W`](W) writer structure"]
        impl crate::Writable for DMASA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DMASA to value 0"]
        impl crate::Resettable for DMASA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "UART1"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0415_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for UART1 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "UART1"]
pub use self::uart0 as uart1;
#[doc = "UART2"]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0416_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for UART2 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
#[doc = "UART2"]
pub use self::uart0 as uart2;
#[doc = "UART3"]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0417_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for UART3 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
#[doc = "UART3"]
pub use self::uart0 as uart3;
#[doc = "UART4"]
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART4 {}
impl UART4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x041c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for UART4 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART4").finish()
    }
}
#[doc = "UART4"]
pub use self::uart0 as uart4;
#[doc = "RTCSYS_UART"]
pub struct RTCSYS_UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTCSYS_UART {}
impl RTCSYS_UART {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x0502_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for RTCSYS_UART {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTCSYS_UART {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTCSYS_UART").finish()
    }
}
#[doc = "RTCSYS_UART"]
pub use self::uart0 as rtcsys_uart;
#[doc = "GPIO0"]
pub struct GPIO0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO0 {}
impl GPIO0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0302_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for GPIO0 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO0").finish()
    }
}
#[doc = "GPIO0"]
pub mod gpio0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        dr: DR,
        ddr: DDR,
        _reserved2: [u8; 0x28],
        inten: INTEN,
        intmask: INTMASK,
        inttype: INTTYPE,
        intpolarity: INTPOLARITY,
        intstatus: INTSTATUS,
        rawintstatus: RAWINTSTATUS,
        debounce: DEBOUNCE,
        eoi: EOI,
        ext: EXT,
        _reserved11: [u8; 0x0c],
        ls_sync: LS_SYNC,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Data register"]
        #[inline(always)]
        pub const fn dr(&self) -> &DR {
            &self.dr
        }
        #[doc = "0x04 - Data direction register, 0: input 1: output"]
        #[inline(always)]
        pub const fn ddr(&self) -> &DDR {
            &self.ddr
        }
        #[doc = "0x30 - Interrupt enable register"]
        #[inline(always)]
        pub const fn inten(&self) -> &INTEN {
            &self.inten
        }
        #[doc = "0x34 - Interrupt mask register"]
        #[inline(always)]
        pub const fn intmask(&self) -> &INTMASK {
            &self.intmask
        }
        #[doc = "0x38 - Interrupt type register, 0: level, 1: edge"]
        #[inline(always)]
        pub const fn inttype(&self) -> &INTTYPE {
            &self.inttype
        }
        #[doc = "0x3c - Interrupt polarity register, 0: active low, 1: active high"]
        #[inline(always)]
        pub const fn intpolarity(&self) -> &INTPOLARITY {
            &self.intpolarity
        }
        #[doc = "0x40 - Interrupt status register"]
        #[inline(always)]
        pub const fn intstatus(&self) -> &INTSTATUS {
            &self.intstatus
        }
        #[doc = "0x44 - Raw interrupt status register (premasking bits)"]
        #[inline(always)]
        pub const fn rawintstatus(&self) -> &RAWINTSTATUS {
            &self.rawintstatus
        }
        #[doc = "0x48 - Debounce enable register"]
        #[inline(always)]
        pub const fn debounce(&self) -> &DEBOUNCE {
            &self.debounce
        }
        #[doc = "0x4c - End of interrupt register, write 1 to clear interrupt"]
        #[inline(always)]
        pub const fn eoi(&self) -> &EOI {
            &self.eoi
        }
        #[doc = "0x50 - External port register"]
        #[inline(always)]
        pub const fn ext(&self) -> &EXT {
            &self.ext
        }
        #[doc = "0x60 - Level-sensitive synchronization enable register"]
        #[inline(always)]
        pub const fn ls_sync(&self) -> &LS_SYNC {
            &self.ls_sync
        }
    }
    #[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`]
module"]
    pub type DR = crate::Reg<dr::DR_SPEC>;
    #[doc = "Data register"]
    pub mod dr {
        #[doc = "Register `DR` reader"]
        pub type R = crate::R<DR_SPEC>;
        #[doc = "Register `DR` writer"]
        pub type W = crate::W<DR_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dr::R`](R) reader structure"]
        impl crate::Readable for DR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"]
        impl crate::Writable for DR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DR to value 0"]
        impl crate::Resettable for DR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DDR (rw) register accessor: Data direction register, 0: input 1: output\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ddr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ddr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ddr`]
module"]
    pub type DDR = crate::Reg<ddr::DDR_SPEC>;
    #[doc = "Data direction register, 0: input 1: output"]
    pub mod ddr {
        #[doc = "Register `DDR` reader"]
        pub type R = crate::R<DDR_SPEC>;
        #[doc = "Register `DDR` writer"]
        pub type W = crate::W<DDR_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DDR_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Data direction register, 0: input 1: output\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ddr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ddr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DDR_SPEC;
        impl crate::RegisterSpec for DDR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ddr::R`](R) reader structure"]
        impl crate::Readable for DDR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ddr::W`](W) writer structure"]
        impl crate::Writable for DDR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DDR to value 0"]
        impl crate::Resettable for DDR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTEN (rw) register accessor: Interrupt enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`inten::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inten::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inten`]
module"]
    pub type INTEN = crate::Reg<inten::INTEN_SPEC>;
    #[doc = "Interrupt enable register"]
    pub mod inten {
        #[doc = "Register `INTEN` reader"]
        pub type R = crate::R<INTEN_SPEC>;
        #[doc = "Register `INTEN` writer"]
        pub type W = crate::W<INTEN_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTEN_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`inten::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inten::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTEN_SPEC;
        impl crate::RegisterSpec for INTEN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`inten::R`](R) reader structure"]
        impl crate::Readable for INTEN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`inten::W`](W) writer structure"]
        impl crate::Writable for INTEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTEN to value 0"]
        impl crate::Resettable for INTEN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTMASK (rw) register accessor: Interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intmask::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intmask::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intmask`]
module"]
    pub type INTMASK = crate::Reg<intmask::INTMASK_SPEC>;
    #[doc = "Interrupt mask register"]
    pub mod intmask {
        #[doc = "Register `INTMASK` reader"]
        pub type R = crate::R<INTMASK_SPEC>;
        #[doc = "Register `INTMASK` writer"]
        pub type W = crate::W<INTMASK_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTMASK_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt mask register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intmask::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intmask::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTMASK_SPEC;
        impl crate::RegisterSpec for INTMASK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`intmask::R`](R) reader structure"]
        impl crate::Readable for INTMASK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`intmask::W`](W) writer structure"]
        impl crate::Writable for INTMASK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTMASK to value 0"]
        impl crate::Resettable for INTMASK_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTTYPE (rw) register accessor: Interrupt type register, 0: level, 1: edge\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`inttype::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inttype::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inttype`]
module"]
    pub type INTTYPE = crate::Reg<inttype::INTTYPE_SPEC>;
    #[doc = "Interrupt type register, 0: level, 1: edge"]
    pub mod inttype {
        #[doc = "Register `INTTYPE` reader"]
        pub type R = crate::R<INTTYPE_SPEC>;
        #[doc = "Register `INTTYPE` writer"]
        pub type W = crate::W<INTTYPE_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTTYPE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt type register, 0: level, 1: edge\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`inttype::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`inttype::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTTYPE_SPEC;
        impl crate::RegisterSpec for INTTYPE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`inttype::R`](R) reader structure"]
        impl crate::Readable for INTTYPE_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`inttype::W`](W) writer structure"]
        impl crate::Writable for INTTYPE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTTYPE to value 0"]
        impl crate::Resettable for INTTYPE_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTPOLARITY (rw) register accessor: Interrupt polarity register, 0: active low, 1: active high\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intpolarity::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intpolarity::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intpolarity`]
module"]
    pub type INTPOLARITY = crate::Reg<intpolarity::INTPOLARITY_SPEC>;
    #[doc = "Interrupt polarity register, 0: active low, 1: active high"]
    pub mod intpolarity {
        #[doc = "Register `INTPOLARITY` reader"]
        pub type R = crate::R<INTPOLARITY_SPEC>;
        #[doc = "Register `INTPOLARITY` writer"]
        pub type W = crate::W<INTPOLARITY_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTPOLARITY_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt polarity register, 0: active low, 1: active high\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intpolarity::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intpolarity::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTPOLARITY_SPEC;
        impl crate::RegisterSpec for INTPOLARITY_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`intpolarity::R`](R) reader structure"]
        impl crate::Readable for INTPOLARITY_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`intpolarity::W`](W) writer structure"]
        impl crate::Writable for INTPOLARITY_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTPOLARITY to value 0"]
        impl crate::Resettable for INTPOLARITY_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTSTATUS (rw) register accessor: Interrupt status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intstatus::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intstatus::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intstatus`]
module"]
    pub type INTSTATUS = crate::Reg<intstatus::INTSTATUS_SPEC>;
    #[doc = "Interrupt status register"]
    pub mod intstatus {
        #[doc = "Register `INTSTATUS` reader"]
        pub type R = crate::R<INTSTATUS_SPEC>;
        #[doc = "Register `INTSTATUS` writer"]
        pub type W = crate::W<INTSTATUS_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<INTSTATUS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intstatus::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intstatus::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTSTATUS_SPEC;
        impl crate::RegisterSpec for INTSTATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`intstatus::R`](R) reader structure"]
        impl crate::Readable for INTSTATUS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`intstatus::W`](W) writer structure"]
        impl crate::Writable for INTSTATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTSTATUS to value 0"]
        impl crate::Resettable for INTSTATUS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "RAWINTSTATUS (rw) register accessor: Raw interrupt status register (premasking bits)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rawintstatus::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rawintstatus::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rawintstatus`]
module"]
    pub type RAWINTSTATUS = crate::Reg<rawintstatus::RAWINTSTATUS_SPEC>;
    #[doc = "Raw interrupt status register (premasking bits)"]
    pub mod rawintstatus {
        #[doc = "Register `RAWINTSTATUS` reader"]
        pub type R = crate::R<RAWINTSTATUS_SPEC>;
        #[doc = "Register `RAWINTSTATUS` writer"]
        pub type W = crate::W<RAWINTSTATUS_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<RAWINTSTATUS_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Raw interrupt status register (premasking bits)\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`rawintstatus::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`rawintstatus::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RAWINTSTATUS_SPEC;
        impl crate::RegisterSpec for RAWINTSTATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rawintstatus::R`](R) reader structure"]
        impl crate::Readable for RAWINTSTATUS_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`rawintstatus::W`](W) writer structure"]
        impl crate::Writable for RAWINTSTATUS_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets RAWINTSTATUS to value 0"]
        impl crate::Resettable for RAWINTSTATUS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DEBOUNCE (rw) register accessor: Debounce enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`debounce::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`debounce::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@debounce`]
module"]
    pub type DEBOUNCE = crate::Reg<debounce::DEBOUNCE_SPEC>;
    #[doc = "Debounce enable register"]
    pub mod debounce {
        #[doc = "Register `DEBOUNCE` reader"]
        pub type R = crate::R<DEBOUNCE_SPEC>;
        #[doc = "Register `DEBOUNCE` writer"]
        pub type W = crate::W<DEBOUNCE_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<DEBOUNCE_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Debounce enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`debounce::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`debounce::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DEBOUNCE_SPEC;
        impl crate::RegisterSpec for DEBOUNCE_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`debounce::R`](R) reader structure"]
        impl crate::Readable for DEBOUNCE_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`debounce::W`](W) writer structure"]
        impl crate::Writable for DEBOUNCE_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DEBOUNCE to value 0"]
        impl crate::Resettable for DEBOUNCE_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EOI (rw) register accessor: End of interrupt register, write 1 to clear interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`eoi::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`eoi::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eoi`]
module"]
    pub type EOI = crate::Reg<eoi::EOI_SPEC>;
    #[doc = "End of interrupt register, write 1 to clear interrupt"]
    pub mod eoi {
        #[doc = "Register `EOI` reader"]
        pub type R = crate::R<EOI_SPEC>;
        #[doc = "Register `EOI` writer"]
        pub type W = crate::W<EOI_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<EOI_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "End of interrupt register, write 1 to clear interrupt\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`eoi::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`eoi::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EOI_SPEC;
        impl crate::RegisterSpec for EOI_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`eoi::R`](R) reader structure"]
        impl crate::Readable for EOI_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`eoi::W`](W) writer structure"]
        impl crate::Writable for EOI_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EOI to value 0"]
        impl crate::Resettable for EOI_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "EXT (rw) register accessor: External port register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ext::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ext::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ext`]
module"]
    pub type EXT = crate::Reg<ext::EXT_SPEC>;
    #[doc = "External port register"]
    pub mod ext {
        #[doc = "Register `EXT` reader"]
        pub type R = crate::R<EXT_SPEC>;
        #[doc = "Register `EXT` writer"]
        pub type W = crate::W<EXT_SPEC>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl core::fmt::Debug for crate::generic::Reg<EXT_SPEC> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                core::fmt::Debug::fmt(&self.read(), f)
            }
        }
        impl W {
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "External port register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ext::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ext::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct EXT_SPEC;
        impl crate::RegisterSpec for EXT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ext::R`](R) reader structure"]
        impl crate::Readable for EXT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ext::W`](W) writer structure"]
        impl crate::Writable for EXT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets EXT to value 0"]
        impl crate::Resettable for EXT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "LS_SYNC (rw) register accessor: Level-sensitive synchronization enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ls_sync::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ls_sync::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ls_sync`]
module"]
    pub type LS_SYNC = crate::Reg<ls_sync::LS_SYNC_SPEC>;
    #[doc = "Level-sensitive synchronization enable register"]
    pub mod ls_sync {
        #[doc = "Register `LS_SYNC` reader"]
        pub type R = crate::R<LS_SYNC_SPEC>;
        #[doc = "Register `LS_SYNC` writer"]
        pub type W = crate::W<LS_SYNC_SPEC>;
        #[doc = "Field `LS_SYNC` reader - Level-sensitive synchronization enable"]
        pub type LS_SYNC_R = crate::BitReader;
        #[doc = "Field `LS_SYNC` writer - Level-sensitive synchronization enable"]
        pub type LS_SYNC_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Level-sensitive synchronization enable"]
            #[inline(always)]
            pub fn ls_sync(&self) -> LS_SYNC_R {
                LS_SYNC_R::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Level-sensitive synchronization enable"]
            #[inline(always)]
            #[must_use]
            pub fn ls_sync(&mut self) -> LS_SYNC_W<LS_SYNC_SPEC> {
                LS_SYNC_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Level-sensitive synchronization enable register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ls_sync::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ls_sync::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LS_SYNC_SPEC;
        impl crate::RegisterSpec for LS_SYNC_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ls_sync::R`](R) reader structure"]
        impl crate::Readable for LS_SYNC_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ls_sync::W`](W) writer structure"]
        impl crate::Writable for LS_SYNC_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets LS_SYNC to value 0"]
        impl crate::Resettable for LS_SYNC_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "GPIO1"]
pub struct GPIO1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO1 {}
impl GPIO1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0302_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for GPIO1 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO1").finish()
    }
}
#[doc = "GPIO1"]
pub use self::gpio0 as gpio1;
#[doc = "GPIO2"]
pub struct GPIO2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO2 {}
impl GPIO2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0302_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for GPIO2 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO2").finish()
    }
}
#[doc = "GPIO2"]
pub use self::gpio0 as gpio2;
#[doc = "GPIO3"]
pub struct GPIO3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO3 {}
impl GPIO3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0302_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for GPIO3 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO3").finish()
    }
}
#[doc = "GPIO3"]
pub use self::gpio0 as gpio3;
#[doc = "PWR_GPIO"]
pub struct PWR_GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR_GPIO {}
impl PWR_GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x0502_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self { _marker: PhantomData }
    }
}
impl Deref for PWR_GPIO {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWR_GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWR_GPIO").finish()
    }
}
#[doc = "PWR_GPIO"]
pub use self::gpio0 as pwr_gpio;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PINMUX"]
    pub PINMUX: PINMUX,
    #[doc = "IOBLK_G10"]
    pub IOBLK_G10: IOBLK_G10,
    #[doc = "IOBLK_G1"]
    pub IOBLK_G1: IOBLK_G1,
    #[doc = "IOBLK_G7"]
    pub IOBLK_G7: IOBLK_G7,
    #[doc = "IOBLK_G12"]
    pub IOBLK_G12: IOBLK_G12,
    #[doc = "IOBLK_RTC"]
    pub IOBLK_RTC: IOBLK_RTC,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
    #[doc = "UART4"]
    pub UART4: UART4,
    #[doc = "RTCSYS_UART"]
    pub RTCSYS_UART: RTCSYS_UART,
    #[doc = "GPIO0"]
    pub GPIO0: GPIO0,
    #[doc = "GPIO1"]
    pub GPIO1: GPIO1,
    #[doc = "GPIO2"]
    pub GPIO2: GPIO2,
    #[doc = "GPIO3"]
    pub GPIO3: GPIO3,
    #[doc = "PWR_GPIO"]
    pub PWR_GPIO: PWR_GPIO,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PINMUX: PINMUX { _marker: PhantomData },
            IOBLK_G10: IOBLK_G10 { _marker: PhantomData },
            IOBLK_G1: IOBLK_G1 { _marker: PhantomData },
            IOBLK_G7: IOBLK_G7 { _marker: PhantomData },
            IOBLK_G12: IOBLK_G12 { _marker: PhantomData },
            IOBLK_RTC: IOBLK_RTC { _marker: PhantomData },
            UART0: UART0 { _marker: PhantomData },
            UART1: UART1 { _marker: PhantomData },
            UART2: UART2 { _marker: PhantomData },
            UART3: UART3 { _marker: PhantomData },
            UART4: UART4 { _marker: PhantomData },
            RTCSYS_UART: RTCSYS_UART { _marker: PhantomData },
            GPIO0: GPIO0 { _marker: PhantomData },
            GPIO1: GPIO1 { _marker: PhantomData },
            GPIO2: GPIO2 { _marker: PhantomData },
            GPIO3: GPIO3 { _marker: PhantomData },
            PWR_GPIO: PWR_GPIO { _marker: PhantomData },
        }
    }
}
